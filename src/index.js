const {
  shiftBlockFocus,
  shiftFieldFocus,
  moveBlock,
  getRegisteredBlocksNameList,
  getBlockInstancesListFromDOM,
  requiredParam
} = require('./utilities/helper.js')

/**
 * Construct Freedom Editor instance
 * @author Hugo Sum
 * @lastUpdateDate 2020-07-16
 * @param          {object}   customOptions An object with options to initialize Freedom Editor instance
 */

/**
 * Default options for Freedom Editor instance
 * @type {Object}
 * @property {[String]} containerId The id of the container for Freedom Editor instance
 * @property {[Array]} blockTemplate An array of block instances.  Blocks listed here will be rendered as template when the editor initialize, and their position will be fixed. This property is required.
 * @property {[Array]} registeredBlocks An array of block instances to be registered in this editor instance.
 * @property {[Array]} blocksControllers Blocks controllers listed here will be applied to all blocks in this editor instance.  You should pass this array through FreedomEditor.init() instead of here.
 * @property {[Object]} options.i18n An Object of internationalization options.  Default "locale" is "en-US" and "rtl" is "auto"
 * @property {[Array]} defaultBlocks Default block(s) to load when user create a new block(s).
 *
 */

function FreedomEditor ({ containerId, i18n, blockTemplate, blocksControllers, registeredBlocks, defaultBlocks }) {
  let options = {
    containerId: containerId || requiredParam('containerId'),
    i18n: i18n || {
      locale: 'en-US',
      rtl: 'auto'
    },
    blockTemplate: blockTemplate || [],
    blocksControllers: blocksControllers || [],
    defaultBlocks: defaultBlocks || requiredParam('defaultBlocks'),
    // Ensure no duplicate values in registeredBlocks
    registeredBlocks: (registeredBlocks) ? [...new Set(registeredBlocks)] : requiredParam('registeredBlocks')
  }

  const editor = document.getElementById(containerId)

  editor.setAttribute('dir', options.i18n.rtl)

  options.editorContainer = editor

  options = Object.freeze(options)

  /**
   * Initialize editor and hook controllers to the editor in editor level.  controllers hooked here will apply to all blocks.
   * @param  {Array} controllersOptions An array containing all init functions of controllers
   * @return {Object} The instance of Freedom Editor
   */
  const init = (controllersOptions = []) => {
    const isAllDefaultBlocksRegistered = options.defaultBlocks.every((defaultBlock) => options.registeredBlocks.includes(defaultBlock))

    if (!isAllDefaultBlocksRegistered) {
      throw new Error('You need to register all your default blocks at options.registeredBlocks')
    }

    options.blockTemplate.forEach((blockInstance) => {
      if (!options.registeredBlocks.includes(blockInstance)) {
        throw new Error('You need to register blocks used in your block template at options.registeredBlocks.')
      }
    })

    return editor
  }

  /**
   * Call render() from blocks and Render block in the DOM
   * @author Hugo Sum
   * @lastUpdateDate 2020-07-18
   * @param          {Object}   blockInstance      A class instance of a block registered at Freedom Editor's instance
   * @param          {Boolean}  isTemplateBlock    True for rendering template block, false for rendering non-template block
   * @param          {Object}   savedData          An object of data generated by save() method of a block instance
   * @return {[DOMString]} newBlock  Rendered block DOM string
   */
  const renderBlock = ({
    blockInstance = requiredParam('blockInstance'),
    isTemplateBlock = 'false',
    savedData
  }) => {
    // Assign order attribute to new block
    const newBlock = blockInstance.render(options.i18n, savedData)
    newBlock.dataset.order = editor.childNodes.length
    if (isTemplateBlock === 'true') {
      newBlock.dataset.blockTemplate = true
    } else {
      newBlock.dataset.blockTemplate = false
    }

    const mergedControllers = options.blocksControllers.map((controllerForAllBlocks) => {
      const controllerToCopyFrom = blockInstance.options.controllers.find((controllerForSpecificBlock) => controllerForAllBlocks.constructor.name === controllerForSpecificBlock.constructor.name)
      return Object.assign(controllerForAllBlocks, controllerToCopyFrom)
    })

    mergedControllers.forEach((controller) => {
      controller.init(this, newBlock)
    })

    editor.append(newBlock)

    return newBlock
  }

  /**
   * Remove a specific block from editor
   * @param  {Object} block Block to be removed from DOM
   * @return {undefined}
   */
  const removeBlock = (block) => {
    if (block.matches('[data-block-template="true"]') || editor.childNodes.length === 1) {
      return
    }

    if (block !== editor.firstElementChild) {
      shiftBlockFocus(block, 'up', block.previousElementSibling)
    } else {
      // Shift focus down if the removing the first block
      shiftBlockFocus(block, 'down', block.nextElementSibling)
    }

    block.remove()
  }

  /**
   * Load blocks with data saved previously
   * @param  {Object} savedData Data you saved with saveBlocks(). If you don't pass any saved Data here, blocks listed in block template will be loaded.
   * @return {Array} Blocks loaded in editor instance
   */
  const loadBlocks = (savedData) => {
    if (!savedData) {
      if (options.blockTemplate.length > 0) {
        return options.blockTemplate.map((block) => renderBlock({
          blockInstance: block,
          isTemplateBlock: 'true'
        }))
      }

      return options.defaultBlocks.map((defaultBlock) => renderBlock({
        blockInstance: defaultBlock,
        isTemplateBlock: 'false'
      }))
    }

    return savedData.data.map((block) => {
      const blockIndexInRegisteredBlockList = getRegisteredBlocksNameList(options).indexOf(block.type)

      if (blockIndexInRegisteredBlockList === -1) {
        throw new Error("You are trying to load a block that you haven't registered when you initzalize the editor")
      }

      // TODO: Fix bug where a block is template or not is not shown in the saved JSON data, thus the loaded block
      return renderBlock({
        blockInstance: options.registeredBlocks[blockIndexInRegisteredBlockList],
        isTemplateBlock: block.isTemplateBlock,
        savedData: block
      })
    })
  }

  /**
   * Save data from all blocks
   * @return {Object} An object containing datas of all blocks and saving timestamp
   */
  const saveBlocks = () => {
    // Get block list in editor in DOM
    const blocksInDOM = [...editor.childNodes]

    const data = blocksInDOM
      .map((blockInDom, index) => getBlockInstancesListFromDOM(options)[index].save(blockInDom))
      .filter(
        blockData => blockData !== (false || undefined)
      )

    return {
      timestamp: Date.now(),
      data: data
    }
  }

  /**
   * Reset editor and only keeps its template block
   */
  const resetBlocks = () => {
    [...editor.childNodes].forEach((block) => {
      if (!block.matches('[data-block-template="true"]')) {
        block.remove()
      } else {
        block.querySelectorAll('[contenteditable]')
          .forEach((editableField) => {
            editableField.textContent = ''
          })
      }
    })

    if (editor.childNodes.length === 0) {
      options.defaultBlocks.forEach((defaultBlock) => {
        renderBlock({
          blockInstance: defaultBlock,
          isTemplateBlock: false
        })
      })
    }
  }

  return {
    options,
    init,
    saveBlocks,
    loadBlocks,
    resetBlocks,
    renderBlock,
    removeBlock
  }
}

module.exports = {
  FreedomEditor
}
